// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: replies.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createReply = `-- name: CreateReply :exec
INSERT INTO replies (
    thread_id, board, from_post, to_post, reply_type
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateReplyParams struct {
	ThreadID  string `json:"thread_id"`
	Board     string `json:"board"`
	FromPost  int64  `json:"from_post"`
	ToPost    int64  `json:"to_post"`
	ReplyType string `json:"reply_type"`
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) error {
	_, err := q.db.ExecContext(ctx, createReply,
		arg.ThreadID,
		arg.Board,
		arg.FromPost,
		arg.ToPost,
		arg.ReplyType,
	)
	return err
}

const getConversationTree = `-- name: GetConversationTree :many
SELECT 
    r.from_post,
    r.to_post,
    r.reply_type,
    p1.clean_text as from_text,
    p1.user_id as from_user_id,
    p1.timestamp as from_timestamp,
    p2.clean_text as to_text,
    p2.user_id as to_user_id,
    p2.timestamp as to_timestamp
FROM replies r
JOIN posts p1 ON r.from_post = p1.post_no AND r.thread_id = p1.thread_id AND r.board = p1.board
JOIN posts p2 ON r.to_post = p2.post_no AND r.thread_id = p2.thread_id AND r.board = p2.board
WHERE r.thread_id = ? AND r.board = ?
ORDER BY r.from_post ASC
`

type GetConversationTreeParams struct {
	ThreadID string `json:"thread_id"`
	Board    string `json:"board"`
}

type GetConversationTreeRow struct {
	FromPost      int64          `json:"from_post"`
	ToPost        int64          `json:"to_post"`
	ReplyType     string         `json:"reply_type"`
	FromText      sql.NullString `json:"from_text"`
	FromUserID    sql.NullString `json:"from_user_id"`
	FromTimestamp int64          `json:"from_timestamp"`
	ToText        sql.NullString `json:"to_text"`
	ToUserID      sql.NullString `json:"to_user_id"`
	ToTimestamp   int64          `json:"to_timestamp"`
}

func (q *Queries) GetConversationTree(ctx context.Context, arg GetConversationTreeParams) ([]GetConversationTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationTree, arg.ThreadID, arg.Board)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationTreeRow{}
	for rows.Next() {
		var i GetConversationTreeRow
		if err := rows.Scan(
			&i.FromPost,
			&i.ToPost,
			&i.ReplyType,
			&i.FromText,
			&i.FromUserID,
			&i.FromTimestamp,
			&i.ToText,
			&i.ToUserID,
			&i.ToTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRepliedPosts = `-- name: GetMostRepliedPosts :many
SELECT 
    r.to_post,
    COUNT(*) as reply_count,
    p.clean_text,
    p.user_id,
    p.timestamp
FROM replies r
JOIN posts p ON r.to_post = p.post_no AND r.thread_id = p.thread_id AND r.board = p.board
WHERE r.thread_id = ? AND r.board = ?
GROUP BY r.to_post
ORDER BY reply_count DESC
LIMIT ?
`

type GetMostRepliedPostsParams struct {
	ThreadID string `json:"thread_id"`
	Board    string `json:"board"`
	Limit    int64  `json:"limit"`
}

type GetMostRepliedPostsRow struct {
	ToPost     int64          `json:"to_post"`
	ReplyCount int64          `json:"reply_count"`
	CleanText  sql.NullString `json:"clean_text"`
	UserID     sql.NullString `json:"user_id"`
	Timestamp  int64          `json:"timestamp"`
}

func (q *Queries) GetMostRepliedPosts(ctx context.Context, arg GetMostRepliedPostsParams) ([]GetMostRepliedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostRepliedPosts, arg.ThreadID, arg.Board, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostRepliedPostsRow{}
	for rows.Next() {
		var i GetMostRepliedPostsRow
		if err := rows.Scan(
			&i.ToPost,
			&i.ReplyCount,
			&i.CleanText,
			&i.UserID,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesFrom = `-- name: GetRepliesFrom :many
SELECT r.id, r.thread_id, r.board, r.from_post, r.to_post, r.reply_type, r.created_at, p.clean_text as to_text 
FROM replies r
JOIN posts p ON r.to_post = p.post_no AND r.thread_id = p.thread_id AND r.board = p.board
WHERE r.thread_id = ? AND r.board = ? AND r.from_post = ?
ORDER BY r.to_post ASC
`

type GetRepliesFromParams struct {
	ThreadID string `json:"thread_id"`
	Board    string `json:"board"`
	FromPost int64  `json:"from_post"`
}

type GetRepliesFromRow struct {
	ID        int64          `json:"id"`
	ThreadID  string         `json:"thread_id"`
	Board     string         `json:"board"`
	FromPost  int64          `json:"from_post"`
	ToPost    int64          `json:"to_post"`
	ReplyType string         `json:"reply_type"`
	CreatedAt time.Time      `json:"created_at"`
	ToText    sql.NullString `json:"to_text"`
}

func (q *Queries) GetRepliesFrom(ctx context.Context, arg GetRepliesFromParams) ([]GetRepliesFromRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepliesFrom, arg.ThreadID, arg.Board, arg.FromPost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRepliesFromRow{}
	for rows.Next() {
		var i GetRepliesFromRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.Board,
			&i.FromPost,
			&i.ToPost,
			&i.ReplyType,
			&i.CreatedAt,
			&i.ToText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesTo = `-- name: GetRepliesTo :many
SELECT r.id, r.thread_id, r.board, r.from_post, r.to_post, r.reply_type, r.created_at, p.clean_text as from_text 
FROM replies r
JOIN posts p ON r.from_post = p.post_no AND r.thread_id = p.thread_id AND r.board = p.board
WHERE r.thread_id = ? AND r.board = ? AND r.to_post = ?
ORDER BY r.from_post ASC
`

type GetRepliesToParams struct {
	ThreadID string `json:"thread_id"`
	Board    string `json:"board"`
	ToPost   int64  `json:"to_post"`
}

type GetRepliesToRow struct {
	ID        int64          `json:"id"`
	ThreadID  string         `json:"thread_id"`
	Board     string         `json:"board"`
	FromPost  int64          `json:"from_post"`
	ToPost    int64          `json:"to_post"`
	ReplyType string         `json:"reply_type"`
	CreatedAt time.Time      `json:"created_at"`
	FromText  sql.NullString `json:"from_text"`
}

func (q *Queries) GetRepliesTo(ctx context.Context, arg GetRepliesToParams) ([]GetRepliesToRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepliesTo, arg.ThreadID, arg.Board, arg.ToPost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRepliesToRow{}
	for rows.Next() {
		var i GetRepliesToRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.Board,
			&i.FromPost,
			&i.ToPost,
			&i.ReplyType,
			&i.CreatedAt,
			&i.FromText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT 
    r.from_post,
    r.to_post,
    r.reply_type,
    p1.clean_text as from_text,
    p2.clean_text as to_text,
    p2.user_id as conversation_partner
FROM replies r
JOIN posts p1 ON r.from_post = p1.post_no AND r.thread_id = p1.thread_id AND r.board = p1.board
JOIN posts p2 ON r.to_post = p2.post_no AND r.thread_id = p2.thread_id AND r.board = p2.board
WHERE r.thread_id = ? AND r.board = ? AND p1.user_id = ?
ORDER BY r.from_post ASC
`

type GetUserConversationsParams struct {
	ThreadID string         `json:"thread_id"`
	Board    string         `json:"board"`
	UserID   sql.NullString `json:"user_id"`
}

type GetUserConversationsRow struct {
	FromPost            int64          `json:"from_post"`
	ToPost              int64          `json:"to_post"`
	ReplyType           string         `json:"reply_type"`
	FromText            sql.NullString `json:"from_text"`
	ToText              sql.NullString `json:"to_text"`
	ConversationPartner sql.NullString `json:"conversation_partner"`
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserConversations, arg.ThreadID, arg.Board, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsRow{}
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.FromPost,
			&i.ToPost,
			&i.ReplyType,
			&i.FromText,
			&i.ToText,
			&i.ConversationPartner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const replyExists = `-- name: ReplyExists :one
SELECT COUNT(*) FROM replies 
WHERE thread_id = ? AND board = ? AND from_post = ? AND to_post = ? AND reply_type = ?
`

type ReplyExistsParams struct {
	ThreadID  string `json:"thread_id"`
	Board     string `json:"board"`
	FromPost  int64  `json:"from_post"`
	ToPost    int64  `json:"to_post"`
	ReplyType string `json:"reply_type"`
}

func (q *Queries) ReplyExists(ctx context.Context, arg ReplyExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, replyExists,
		arg.ThreadID,
		arg.Board,
		arg.FromPost,
		arg.ToPost,
		arg.ReplyType,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}
